import LeanAideCore
import Mathlib
set_option linter.style.commandStart false
set_option linter.style.longLine false

#leanaide_connect "http://drongo:8042"

/-
### Theorem:
Let $T : V \to V$ be a linear transformation on a finite-dimensional vector space $V$.
If $T^2 = T$, then
\[
V = \ker(T) \oplus \operatorname{im}(T).
\]
### Proof:

Assume that $V$ is a finite-dimensional vector space and that $T : V \to V$ is a linear map satisfying $T^2 = T$.

First, observe that the condition $T^2 = T$ means that for every $v \in V$ one has $T(T(v)) = T(v)$. In particular, for any $v \in \operatorname{im}(T)$, there exists $u \in V$ such that $v = T(u)$, and then
\[
T(v) = T(T(u)) = T(u) = v.
\]
Thus $T$ acts as the identity on $\operatorname{im}(T)$.

Next, show that $V = \ker(T) + \operatorname{im}(T)$. Let $v \in V$ be arbitrary. Define
\[
w := v - T(v).
\]
Then $w \in \ker(T)$, because
\[
T(w) = T(v - T(v)) = T(v) - T(T(v)) = T(v) - T(v) = 0.
\]
Also $T(v) \in \operatorname{im}(T)$ by definition. Hence every $v \in V$ can be written as
\[
v = w + T(v)
\]
with $w \in \ker(T)$ and $T(v) \in \operatorname{im}(T)$. This shows that
\[
V = \ker(T) + \operatorname{im}(T).
\]

It remains to prove that this sum is direct, that is,
\[
\ker(T) \cap \operatorname{im}(T) = \{0\}.
\]
Let $v \in \ker(T) \cap \operatorname{im}(T)$. Then $v \in \ker(T)$ implies $T(v) = 0$, and $v \in \operatorname{im}(T)$ implies, as shown above, that $T(v) = v$. Combining these equalities gives
\[
v = T(v) = 0,
\]
so $v = 0$. Thus $\ker(T) \cap \operatorname{im}(T) = \{0\}$.

Since every $v \in V$ is a sum of an element of $\ker(T)$ and an element of $\operatorname{im}(T)$, and the intersection $\ker(T) \cap \operatorname{im}(T)$ is $\{0\}$, it follows that
\[
V = \ker(T) \oplus \operatorname{im}(T).
\]
-/

--### JSON Structured Proof

def example21 := json% {
  "document": {
    "type": "document",
    "body": [
      {
        "type": "Theorem",
        "label": "thm:projection-decomposition",
        "header": "Theorem",
        "hypothesis": [
          {
            "type": "assume_statement",
            "assumption": "V is a finite-dimensional vector space."
          },
          {
            "type": "assume_statement",
            "assumption": "T : V → V is a linear transformation satisfying T^2 = T."
          }
        ],
        "claim": "If T^2 = T for a linear transformation T : V → V on a finite-dimensional vector space V, then V = ker(T) ⊕ im(T).",
        "proof": [
          {
            "type": "assert_statement",
            "claim": "For every v ∈ V, one has T(T(v)) = T(v). In particular, for any v ∈ im(T), there exists u ∈ V such that v = T(u), and then T(v) = v, so T acts as the identity on im(T).",
            "proof_method": "Direct computation using T^2 = T"
          },
          {
            "type": "assert_statement",
            "claim": "For any v ∈ V, if we define w := v − T(v), then w ∈ ker(T).",
            "proof_method": "Direct computation: T(w) = T(v − T(v)) = T(v) − T(T(v)) = T(v) − T(v) = 0"
          },
          {
            "type": "assert_statement",
            "claim": "For any v ∈ V, we can write v = w + T(v) with w ∈ ker(T) and T(v) ∈ im(T), so V = ker(T) + im(T).",
            "proof_method": "Decomposition v = (v − T(v)) + T(v) with the previous assertion and the definition of im(T)"
          },
          {
            "type": "assert_statement",
            "claim": "ker(T) ∩ im(T) = {0}.",
            "proof_method": "If v ∈ ker(T) ∩ im(T), then T(v) = 0 and, since v ∈ im(T), T(v) = v by the first assertion; hence v = 0."
          },
          {
            "type": "conclude_statement",
            "claim": "Since V = ker(T) + im(T) and ker(T) ∩ im(T) = {0}, it follows that V = ker(T) ⊕ im(T)."
          }
        ]
      }
    ]
  }
}

-- ## LeanCode generated by LeanAide
theorem linear_map.is_compl_ker_range_of_idempotent :
      ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V]
        [inst_2 : Module K V] [FiniteDimensional K V] (T : V →ₗ[K] V),
        IsIdempotentElem T → IsCompl (LinearMap.ker T) (LinearMap.range T) :=
    by
    intro K V inst inst_1 inst_2 inst_7439058897038094550 T a_6039170471130198741
    grind only [IsCompl.symm, LinearMap.IsIdempotentElem.isCompl] 